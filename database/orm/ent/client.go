// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/common-library/go/database/orm/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/common-library/go/database/orm/ent/issueforent"
	"github.com/common-library/go/database/orm/ent/repositoryforent"
	"github.com/common-library/go/database/orm/ent/table01forent"
	"github.com/common-library/go/database/orm/ent/userforent"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// IssueForEnt is the client for interacting with the IssueForEnt builders.
	IssueForEnt *IssueForEntClient
	// RepositoryForEnt is the client for interacting with the RepositoryForEnt builders.
	RepositoryForEnt *RepositoryForEntClient
	// Table01ForEnt is the client for interacting with the Table01ForEnt builders.
	Table01ForEnt *Table01ForEntClient
	// UserForEnt is the client for interacting with the UserForEnt builders.
	UserForEnt *UserForEntClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.IssueForEnt = NewIssueForEntClient(c.config)
	c.RepositoryForEnt = NewRepositoryForEntClient(c.config)
	c.Table01ForEnt = NewTable01ForEntClient(c.config)
	c.UserForEnt = NewUserForEntClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		IssueForEnt:      NewIssueForEntClient(cfg),
		RepositoryForEnt: NewRepositoryForEntClient(cfg),
		Table01ForEnt:    NewTable01ForEntClient(cfg),
		UserForEnt:       NewUserForEntClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		IssueForEnt:      NewIssueForEntClient(cfg),
		RepositoryForEnt: NewRepositoryForEntClient(cfg),
		Table01ForEnt:    NewTable01ForEntClient(cfg),
		UserForEnt:       NewUserForEntClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		IssueForEnt.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.IssueForEnt.Use(hooks...)
	c.RepositoryForEnt.Use(hooks...)
	c.Table01ForEnt.Use(hooks...)
	c.UserForEnt.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.IssueForEnt.Intercept(interceptors...)
	c.RepositoryForEnt.Intercept(interceptors...)
	c.Table01ForEnt.Intercept(interceptors...)
	c.UserForEnt.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *IssueForEntMutation:
		return c.IssueForEnt.mutate(ctx, m)
	case *RepositoryForEntMutation:
		return c.RepositoryForEnt.mutate(ctx, m)
	case *Table01ForEntMutation:
		return c.Table01ForEnt.mutate(ctx, m)
	case *UserForEntMutation:
		return c.UserForEnt.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// IssueForEntClient is a client for the IssueForEnt schema.
type IssueForEntClient struct {
	config
}

// NewIssueForEntClient returns a client for the IssueForEnt from the given config.
func NewIssueForEntClient(c config) *IssueForEntClient {
	return &IssueForEntClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `issueforent.Hooks(f(g(h())))`.
func (c *IssueForEntClient) Use(hooks ...Hook) {
	c.hooks.IssueForEnt = append(c.hooks.IssueForEnt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `issueforent.Intercept(f(g(h())))`.
func (c *IssueForEntClient) Intercept(interceptors ...Interceptor) {
	c.inters.IssueForEnt = append(c.inters.IssueForEnt, interceptors...)
}

// Create returns a builder for creating a IssueForEnt entity.
func (c *IssueForEntClient) Create() *IssueForEntCreate {
	mutation := newIssueForEntMutation(c.config, OpCreate)
	return &IssueForEntCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IssueForEnt entities.
func (c *IssueForEntClient) CreateBulk(builders ...*IssueForEntCreate) *IssueForEntCreateBulk {
	return &IssueForEntCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IssueForEntClient) MapCreateBulk(slice any, setFunc func(*IssueForEntCreate, int)) *IssueForEntCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IssueForEntCreateBulk{err: fmt.Errorf("calling to IssueForEntClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IssueForEntCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IssueForEntCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IssueForEnt.
func (c *IssueForEntClient) Update() *IssueForEntUpdate {
	mutation := newIssueForEntMutation(c.config, OpUpdate)
	return &IssueForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IssueForEntClient) UpdateOne(ife *IssueForEnt) *IssueForEntUpdateOne {
	mutation := newIssueForEntMutation(c.config, OpUpdateOne, withIssueForEnt(ife))
	return &IssueForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IssueForEntClient) UpdateOneID(id int) *IssueForEntUpdateOne {
	mutation := newIssueForEntMutation(c.config, OpUpdateOne, withIssueForEntID(id))
	return &IssueForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IssueForEnt.
func (c *IssueForEntClient) Delete() *IssueForEntDelete {
	mutation := newIssueForEntMutation(c.config, OpDelete)
	return &IssueForEntDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IssueForEntClient) DeleteOne(ife *IssueForEnt) *IssueForEntDeleteOne {
	return c.DeleteOneID(ife.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IssueForEntClient) DeleteOneID(id int) *IssueForEntDeleteOne {
	builder := c.Delete().Where(issueforent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IssueForEntDeleteOne{builder}
}

// Query returns a query builder for IssueForEnt.
func (c *IssueForEntClient) Query() *IssueForEntQuery {
	return &IssueForEntQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIssueForEnt},
		inters: c.Interceptors(),
	}
}

// Get returns a IssueForEnt entity by its id.
func (c *IssueForEntClient) Get(ctx context.Context, id int) (*IssueForEnt, error) {
	return c.Query().Where(issueforent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IssueForEntClient) GetX(ctx context.Context, id int) *IssueForEnt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the repository edge of a IssueForEnt.
func (c *IssueForEntClient) QueryRepository(ife *IssueForEnt) *RepositoryForEntQuery {
	query := (&RepositoryForEntClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ife.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issueforent.Table, issueforent.FieldID, id),
			sqlgraph.To(repositoryforent.Table, repositoryforent.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, issueforent.RepositoryTable, issueforent.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(ife.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IssueForEntClient) Hooks() []Hook {
	return c.hooks.IssueForEnt
}

// Interceptors returns the client interceptors.
func (c *IssueForEntClient) Interceptors() []Interceptor {
	return c.inters.IssueForEnt
}

func (c *IssueForEntClient) mutate(ctx context.Context, m *IssueForEntMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IssueForEntCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IssueForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IssueForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IssueForEntDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IssueForEnt mutation op: %q", m.Op())
	}
}

// RepositoryForEntClient is a client for the RepositoryForEnt schema.
type RepositoryForEntClient struct {
	config
}

// NewRepositoryForEntClient returns a client for the RepositoryForEnt from the given config.
func NewRepositoryForEntClient(c config) *RepositoryForEntClient {
	return &RepositoryForEntClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repositoryforent.Hooks(f(g(h())))`.
func (c *RepositoryForEntClient) Use(hooks ...Hook) {
	c.hooks.RepositoryForEnt = append(c.hooks.RepositoryForEnt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repositoryforent.Intercept(f(g(h())))`.
func (c *RepositoryForEntClient) Intercept(interceptors ...Interceptor) {
	c.inters.RepositoryForEnt = append(c.inters.RepositoryForEnt, interceptors...)
}

// Create returns a builder for creating a RepositoryForEnt entity.
func (c *RepositoryForEntClient) Create() *RepositoryForEntCreate {
	mutation := newRepositoryForEntMutation(c.config, OpCreate)
	return &RepositoryForEntCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RepositoryForEnt entities.
func (c *RepositoryForEntClient) CreateBulk(builders ...*RepositoryForEntCreate) *RepositoryForEntCreateBulk {
	return &RepositoryForEntCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepositoryForEntClient) MapCreateBulk(slice any, setFunc func(*RepositoryForEntCreate, int)) *RepositoryForEntCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepositoryForEntCreateBulk{err: fmt.Errorf("calling to RepositoryForEntClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepositoryForEntCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepositoryForEntCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RepositoryForEnt.
func (c *RepositoryForEntClient) Update() *RepositoryForEntUpdate {
	mutation := newRepositoryForEntMutation(c.config, OpUpdate)
	return &RepositoryForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepositoryForEntClient) UpdateOne(rfe *RepositoryForEnt) *RepositoryForEntUpdateOne {
	mutation := newRepositoryForEntMutation(c.config, OpUpdateOne, withRepositoryForEnt(rfe))
	return &RepositoryForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepositoryForEntClient) UpdateOneID(id int) *RepositoryForEntUpdateOne {
	mutation := newRepositoryForEntMutation(c.config, OpUpdateOne, withRepositoryForEntID(id))
	return &RepositoryForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RepositoryForEnt.
func (c *RepositoryForEntClient) Delete() *RepositoryForEntDelete {
	mutation := newRepositoryForEntMutation(c.config, OpDelete)
	return &RepositoryForEntDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepositoryForEntClient) DeleteOne(rfe *RepositoryForEnt) *RepositoryForEntDeleteOne {
	return c.DeleteOneID(rfe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepositoryForEntClient) DeleteOneID(id int) *RepositoryForEntDeleteOne {
	builder := c.Delete().Where(repositoryforent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepositoryForEntDeleteOne{builder}
}

// Query returns a query builder for RepositoryForEnt.
func (c *RepositoryForEntClient) Query() *RepositoryForEntQuery {
	return &RepositoryForEntQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepositoryForEnt},
		inters: c.Interceptors(),
	}
}

// Get returns a RepositoryForEnt entity by its id.
func (c *RepositoryForEntClient) Get(ctx context.Context, id int) (*RepositoryForEnt, error) {
	return c.Query().Where(repositoryforent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepositoryForEntClient) GetX(ctx context.Context, id int) *RepositoryForEnt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserForEnts queries the user_for_ents edge of a RepositoryForEnt.
func (c *RepositoryForEntClient) QueryUserForEnts(rfe *RepositoryForEnt) *UserForEntQuery {
	query := (&UserForEntClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repositoryforent.Table, repositoryforent.FieldID, id),
			sqlgraph.To(userforent.Table, userforent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, repositoryforent.UserForEntsTable, repositoryforent.UserForEntsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(rfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssueForEnts queries the issue_for_ents edge of a RepositoryForEnt.
func (c *RepositoryForEntClient) QueryIssueForEnts(rfe *RepositoryForEnt) *IssueForEntQuery {
	query := (&IssueForEntClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rfe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repositoryforent.Table, repositoryforent.FieldID, id),
			sqlgraph.To(issueforent.Table, issueforent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repositoryforent.IssueForEntsTable, repositoryforent.IssueForEntsColumn),
		)
		fromV = sqlgraph.Neighbors(rfe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepositoryForEntClient) Hooks() []Hook {
	return c.hooks.RepositoryForEnt
}

// Interceptors returns the client interceptors.
func (c *RepositoryForEntClient) Interceptors() []Interceptor {
	return c.inters.RepositoryForEnt
}

func (c *RepositoryForEntClient) mutate(ctx context.Context, m *RepositoryForEntMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepositoryForEntCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepositoryForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepositoryForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepositoryForEntDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RepositoryForEnt mutation op: %q", m.Op())
	}
}

// Table01ForEntClient is a client for the Table01ForEnt schema.
type Table01ForEntClient struct {
	config
}

// NewTable01ForEntClient returns a client for the Table01ForEnt from the given config.
func NewTable01ForEntClient(c config) *Table01ForEntClient {
	return &Table01ForEntClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `table01forent.Hooks(f(g(h())))`.
func (c *Table01ForEntClient) Use(hooks ...Hook) {
	c.hooks.Table01ForEnt = append(c.hooks.Table01ForEnt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `table01forent.Intercept(f(g(h())))`.
func (c *Table01ForEntClient) Intercept(interceptors ...Interceptor) {
	c.inters.Table01ForEnt = append(c.inters.Table01ForEnt, interceptors...)
}

// Create returns a builder for creating a Table01ForEnt entity.
func (c *Table01ForEntClient) Create() *Table01ForEntCreate {
	mutation := newTable01ForEntMutation(c.config, OpCreate)
	return &Table01ForEntCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Table01ForEnt entities.
func (c *Table01ForEntClient) CreateBulk(builders ...*Table01ForEntCreate) *Table01ForEntCreateBulk {
	return &Table01ForEntCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *Table01ForEntClient) MapCreateBulk(slice any, setFunc func(*Table01ForEntCreate, int)) *Table01ForEntCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &Table01ForEntCreateBulk{err: fmt.Errorf("calling to Table01ForEntClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*Table01ForEntCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &Table01ForEntCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Table01ForEnt.
func (c *Table01ForEntClient) Update() *Table01ForEntUpdate {
	mutation := newTable01ForEntMutation(c.config, OpUpdate)
	return &Table01ForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *Table01ForEntClient) UpdateOne(te *Table01ForEnt) *Table01ForEntUpdateOne {
	mutation := newTable01ForEntMutation(c.config, OpUpdateOne, withTable01ForEnt(te))
	return &Table01ForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *Table01ForEntClient) UpdateOneID(id int) *Table01ForEntUpdateOne {
	mutation := newTable01ForEntMutation(c.config, OpUpdateOne, withTable01ForEntID(id))
	return &Table01ForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Table01ForEnt.
func (c *Table01ForEntClient) Delete() *Table01ForEntDelete {
	mutation := newTable01ForEntMutation(c.config, OpDelete)
	return &Table01ForEntDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *Table01ForEntClient) DeleteOne(te *Table01ForEnt) *Table01ForEntDeleteOne {
	return c.DeleteOneID(te.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *Table01ForEntClient) DeleteOneID(id int) *Table01ForEntDeleteOne {
	builder := c.Delete().Where(table01forent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &Table01ForEntDeleteOne{builder}
}

// Query returns a query builder for Table01ForEnt.
func (c *Table01ForEntClient) Query() *Table01ForEntQuery {
	return &Table01ForEntQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTable01ForEnt},
		inters: c.Interceptors(),
	}
}

// Get returns a Table01ForEnt entity by its id.
func (c *Table01ForEntClient) Get(ctx context.Context, id int) (*Table01ForEnt, error) {
	return c.Query().Where(table01forent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *Table01ForEntClient) GetX(ctx context.Context, id int) *Table01ForEnt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *Table01ForEntClient) Hooks() []Hook {
	return c.hooks.Table01ForEnt
}

// Interceptors returns the client interceptors.
func (c *Table01ForEntClient) Interceptors() []Interceptor {
	return c.inters.Table01ForEnt
}

func (c *Table01ForEntClient) mutate(ctx context.Context, m *Table01ForEntMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&Table01ForEntCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&Table01ForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&Table01ForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&Table01ForEntDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Table01ForEnt mutation op: %q", m.Op())
	}
}

// UserForEntClient is a client for the UserForEnt schema.
type UserForEntClient struct {
	config
}

// NewUserForEntClient returns a client for the UserForEnt from the given config.
func NewUserForEntClient(c config) *UserForEntClient {
	return &UserForEntClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userforent.Hooks(f(g(h())))`.
func (c *UserForEntClient) Use(hooks ...Hook) {
	c.hooks.UserForEnt = append(c.hooks.UserForEnt, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userforent.Intercept(f(g(h())))`.
func (c *UserForEntClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserForEnt = append(c.inters.UserForEnt, interceptors...)
}

// Create returns a builder for creating a UserForEnt entity.
func (c *UserForEntClient) Create() *UserForEntCreate {
	mutation := newUserForEntMutation(c.config, OpCreate)
	return &UserForEntCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserForEnt entities.
func (c *UserForEntClient) CreateBulk(builders ...*UserForEntCreate) *UserForEntCreateBulk {
	return &UserForEntCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserForEntClient) MapCreateBulk(slice any, setFunc func(*UserForEntCreate, int)) *UserForEntCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserForEntCreateBulk{err: fmt.Errorf("calling to UserForEntClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserForEntCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserForEntCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserForEnt.
func (c *UserForEntClient) Update() *UserForEntUpdate {
	mutation := newUserForEntMutation(c.config, OpUpdate)
	return &UserForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserForEntClient) UpdateOne(ufe *UserForEnt) *UserForEntUpdateOne {
	mutation := newUserForEntMutation(c.config, OpUpdateOne, withUserForEnt(ufe))
	return &UserForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserForEntClient) UpdateOneID(id int) *UserForEntUpdateOne {
	mutation := newUserForEntMutation(c.config, OpUpdateOne, withUserForEntID(id))
	return &UserForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserForEnt.
func (c *UserForEntClient) Delete() *UserForEntDelete {
	mutation := newUserForEntMutation(c.config, OpDelete)
	return &UserForEntDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserForEntClient) DeleteOne(ufe *UserForEnt) *UserForEntDeleteOne {
	return c.DeleteOneID(ufe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserForEntClient) DeleteOneID(id int) *UserForEntDeleteOne {
	builder := c.Delete().Where(userforent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserForEntDeleteOne{builder}
}

// Query returns a query builder for UserForEnt.
func (c *UserForEntClient) Query() *UserForEntQuery {
	return &UserForEntQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserForEnt},
		inters: c.Interceptors(),
	}
}

// Get returns a UserForEnt entity by its id.
func (c *UserForEntClient) Get(ctx context.Context, id int) (*UserForEnt, error) {
	return c.Query().Where(userforent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserForEntClient) GetX(ctx context.Context, id int) *UserForEnt {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepositoryForEnts queries the repository_for_ents edge of a UserForEnt.
func (c *UserForEntClient) QueryRepositoryForEnts(ufe *UserForEnt) *RepositoryForEntQuery {
	query := (&RepositoryForEntClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ufe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userforent.Table, userforent.FieldID, id),
			sqlgraph.To(repositoryforent.Table, repositoryforent.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, userforent.RepositoryForEntsTable, userforent.RepositoryForEntsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ufe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserForEntClient) Hooks() []Hook {
	return c.hooks.UserForEnt
}

// Interceptors returns the client interceptors.
func (c *UserForEntClient) Interceptors() []Interceptor {
	return c.inters.UserForEnt
}

func (c *UserForEntClient) mutate(ctx context.Context, m *UserForEntMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserForEntCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserForEntUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserForEntUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserForEntDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserForEnt mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		IssueForEnt, RepositoryForEnt, Table01ForEnt, UserForEnt []ent.Hook
	}
	inters struct {
		IssueForEnt, RepositoryForEnt, Table01ForEnt, UserForEnt []ent.Interceptor
	}
)
