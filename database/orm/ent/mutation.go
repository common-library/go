// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/common-library/go/database/orm/ent/issueforent"
	"github.com/common-library/go/database/orm/ent/predicate"
	"github.com/common-library/go/database/orm/ent/repositoryforent"
	"github.com/common-library/go/database/orm/ent/table01forent"
	"github.com/common-library/go/database/orm/ent/userforent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeIssueForEnt      = "IssueForEnt"
	TypeRepositoryForEnt = "RepositoryForEnt"
	TypeTable01ForEnt    = "Table01ForEnt"
	TypeUserForEnt       = "UserForEnt"
)

// IssueForEntMutation represents an operation that mutates the IssueForEnt nodes in the graph.
type IssueForEntMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	repository        *int
	clearedrepository bool
	done              bool
	oldValue          func(context.Context) (*IssueForEnt, error)
	predicates        []predicate.IssueForEnt
}

var _ ent.Mutation = (*IssueForEntMutation)(nil)

// issueforentOption allows management of the mutation configuration using functional options.
type issueforentOption func(*IssueForEntMutation)

// newIssueForEntMutation creates new mutation for the IssueForEnt entity.
func newIssueForEntMutation(c config, op Op, opts ...issueforentOption) *IssueForEntMutation {
	m := &IssueForEntMutation{
		config:        c,
		op:            op,
		typ:           TypeIssueForEnt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssueForEntID sets the ID field of the mutation.
func withIssueForEntID(id int) issueforentOption {
	return func(m *IssueForEntMutation) {
		var (
			err   error
			once  sync.Once
			value *IssueForEnt
		)
		m.oldValue = func(ctx context.Context) (*IssueForEnt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssueForEnt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssueForEnt sets the old IssueForEnt of the mutation.
func withIssueForEnt(node *IssueForEnt) issueforentOption {
	return func(m *IssueForEntMutation) {
		m.oldValue = func(context.Context) (*IssueForEnt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssueForEntMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssueForEntMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssueForEntMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssueForEntMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssueForEnt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepositoryID sets the "repository" edge to the RepositoryForEnt entity by id.
func (m *IssueForEntMutation) SetRepositoryID(id int) {
	m.repository = &id
}

// ClearRepository clears the "repository" edge to the RepositoryForEnt entity.
func (m *IssueForEntMutation) ClearRepository() {
	m.clearedrepository = true
}

// RepositoryCleared reports if the "repository" edge to the RepositoryForEnt entity was cleared.
func (m *IssueForEntMutation) RepositoryCleared() bool {
	return m.clearedrepository
}

// RepositoryID returns the "repository" edge ID in the mutation.
func (m *IssueForEntMutation) RepositoryID() (id int, exists bool) {
	if m.repository != nil {
		return *m.repository, true
	}
	return
}

// RepositoryIDs returns the "repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *IssueForEntMutation) RepositoryIDs() (ids []int) {
	if id := m.repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "repository" edge.
func (m *IssueForEntMutation) ResetRepository() {
	m.repository = nil
	m.clearedrepository = false
}

// Where appends a list predicates to the IssueForEntMutation builder.
func (m *IssueForEntMutation) Where(ps ...predicate.IssueForEnt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssueForEntMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssueForEntMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssueForEnt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssueForEntMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssueForEntMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssueForEnt).
func (m *IssueForEntMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssueForEntMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssueForEntMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssueForEntMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown IssueForEnt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueForEntMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssueForEnt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssueForEntMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssueForEntMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssueForEntMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown IssueForEnt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssueForEntMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssueForEntMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssueForEntMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssueForEnt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssueForEntMutation) ResetField(name string) error {
	return fmt.Errorf("unknown IssueForEnt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssueForEntMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repository != nil {
		edges = append(edges, issueforent.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssueForEntMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issueforent.EdgeRepository:
		if id := m.repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssueForEntMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssueForEntMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssueForEntMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepository {
		edges = append(edges, issueforent.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssueForEntMutation) EdgeCleared(name string) bool {
	switch name {
	case issueforent.EdgeRepository:
		return m.clearedrepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssueForEntMutation) ClearEdge(name string) error {
	switch name {
	case issueforent.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown IssueForEnt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssueForEntMutation) ResetEdge(name string) error {
	switch name {
	case issueforent.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown IssueForEnt edge %s", name)
}

// RepositoryForEntMutation represents an operation that mutates the RepositoryForEnt nodes in the graph.
type RepositoryForEntMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	clearedFields         map[string]struct{}
	user_for_ents         map[int]struct{}
	removeduser_for_ents  map[int]struct{}
	cleareduser_for_ents  bool
	issue_for_ents        map[int]struct{}
	removedissue_for_ents map[int]struct{}
	clearedissue_for_ents bool
	done                  bool
	oldValue              func(context.Context) (*RepositoryForEnt, error)
	predicates            []predicate.RepositoryForEnt
}

var _ ent.Mutation = (*RepositoryForEntMutation)(nil)

// repositoryforentOption allows management of the mutation configuration using functional options.
type repositoryforentOption func(*RepositoryForEntMutation)

// newRepositoryForEntMutation creates new mutation for the RepositoryForEnt entity.
func newRepositoryForEntMutation(c config, op Op, opts ...repositoryforentOption) *RepositoryForEntMutation {
	m := &RepositoryForEntMutation{
		config:        c,
		op:            op,
		typ:           TypeRepositoryForEnt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryForEntID sets the ID field of the mutation.
func withRepositoryForEntID(id int) repositoryforentOption {
	return func(m *RepositoryForEntMutation) {
		var (
			err   error
			once  sync.Once
			value *RepositoryForEnt
		)
		m.oldValue = func(ctx context.Context) (*RepositoryForEnt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RepositoryForEnt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepositoryForEnt sets the old RepositoryForEnt of the mutation.
func withRepositoryForEnt(node *RepositoryForEnt) repositoryforentOption {
	return func(m *RepositoryForEntMutation) {
		m.oldValue = func(context.Context) (*RepositoryForEnt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryForEntMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryForEntMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryForEntMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryForEntMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RepositoryForEnt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddUserForEntIDs adds the "user_for_ents" edge to the UserForEnt entity by ids.
func (m *RepositoryForEntMutation) AddUserForEntIDs(ids ...int) {
	if m.user_for_ents == nil {
		m.user_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		m.user_for_ents[ids[i]] = struct{}{}
	}
}

// ClearUserForEnts clears the "user_for_ents" edge to the UserForEnt entity.
func (m *RepositoryForEntMutation) ClearUserForEnts() {
	m.cleareduser_for_ents = true
}

// UserForEntsCleared reports if the "user_for_ents" edge to the UserForEnt entity was cleared.
func (m *RepositoryForEntMutation) UserForEntsCleared() bool {
	return m.cleareduser_for_ents
}

// RemoveUserForEntIDs removes the "user_for_ents" edge to the UserForEnt entity by IDs.
func (m *RepositoryForEntMutation) RemoveUserForEntIDs(ids ...int) {
	if m.removeduser_for_ents == nil {
		m.removeduser_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_for_ents, ids[i])
		m.removeduser_for_ents[ids[i]] = struct{}{}
	}
}

// RemovedUserForEnts returns the removed IDs of the "user_for_ents" edge to the UserForEnt entity.
func (m *RepositoryForEntMutation) RemovedUserForEntsIDs() (ids []int) {
	for id := range m.removeduser_for_ents {
		ids = append(ids, id)
	}
	return
}

// UserForEntsIDs returns the "user_for_ents" edge IDs in the mutation.
func (m *RepositoryForEntMutation) UserForEntsIDs() (ids []int) {
	for id := range m.user_for_ents {
		ids = append(ids, id)
	}
	return
}

// ResetUserForEnts resets all changes to the "user_for_ents" edge.
func (m *RepositoryForEntMutation) ResetUserForEnts() {
	m.user_for_ents = nil
	m.cleareduser_for_ents = false
	m.removeduser_for_ents = nil
}

// AddIssueForEntIDs adds the "issue_for_ents" edge to the IssueForEnt entity by ids.
func (m *RepositoryForEntMutation) AddIssueForEntIDs(ids ...int) {
	if m.issue_for_ents == nil {
		m.issue_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		m.issue_for_ents[ids[i]] = struct{}{}
	}
}

// ClearIssueForEnts clears the "issue_for_ents" edge to the IssueForEnt entity.
func (m *RepositoryForEntMutation) ClearIssueForEnts() {
	m.clearedissue_for_ents = true
}

// IssueForEntsCleared reports if the "issue_for_ents" edge to the IssueForEnt entity was cleared.
func (m *RepositoryForEntMutation) IssueForEntsCleared() bool {
	return m.clearedissue_for_ents
}

// RemoveIssueForEntIDs removes the "issue_for_ents" edge to the IssueForEnt entity by IDs.
func (m *RepositoryForEntMutation) RemoveIssueForEntIDs(ids ...int) {
	if m.removedissue_for_ents == nil {
		m.removedissue_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.issue_for_ents, ids[i])
		m.removedissue_for_ents[ids[i]] = struct{}{}
	}
}

// RemovedIssueForEnts returns the removed IDs of the "issue_for_ents" edge to the IssueForEnt entity.
func (m *RepositoryForEntMutation) RemovedIssueForEntsIDs() (ids []int) {
	for id := range m.removedissue_for_ents {
		ids = append(ids, id)
	}
	return
}

// IssueForEntsIDs returns the "issue_for_ents" edge IDs in the mutation.
func (m *RepositoryForEntMutation) IssueForEntsIDs() (ids []int) {
	for id := range m.issue_for_ents {
		ids = append(ids, id)
	}
	return
}

// ResetIssueForEnts resets all changes to the "issue_for_ents" edge.
func (m *RepositoryForEntMutation) ResetIssueForEnts() {
	m.issue_for_ents = nil
	m.clearedissue_for_ents = false
	m.removedissue_for_ents = nil
}

// Where appends a list predicates to the RepositoryForEntMutation builder.
func (m *RepositoryForEntMutation) Where(ps ...predicate.RepositoryForEnt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryForEntMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryForEntMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RepositoryForEnt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryForEntMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryForEntMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RepositoryForEnt).
func (m *RepositoryForEntMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryForEntMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryForEntMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryForEntMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown RepositoryForEnt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryForEntMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RepositoryForEnt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryForEntMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryForEntMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryForEntMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown RepositoryForEnt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryForEntMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryForEntMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryForEntMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RepositoryForEnt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryForEntMutation) ResetField(name string) error {
	return fmt.Errorf("unknown RepositoryForEnt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryForEntMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user_for_ents != nil {
		edges = append(edges, repositoryforent.EdgeUserForEnts)
	}
	if m.issue_for_ents != nil {
		edges = append(edges, repositoryforent.EdgeIssueForEnts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryForEntMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repositoryforent.EdgeUserForEnts:
		ids := make([]ent.Value, 0, len(m.user_for_ents))
		for id := range m.user_for_ents {
			ids = append(ids, id)
		}
		return ids
	case repositoryforent.EdgeIssueForEnts:
		ids := make([]ent.Value, 0, len(m.issue_for_ents))
		for id := range m.issue_for_ents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryForEntMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_for_ents != nil {
		edges = append(edges, repositoryforent.EdgeUserForEnts)
	}
	if m.removedissue_for_ents != nil {
		edges = append(edges, repositoryforent.EdgeIssueForEnts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryForEntMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repositoryforent.EdgeUserForEnts:
		ids := make([]ent.Value, 0, len(m.removeduser_for_ents))
		for id := range m.removeduser_for_ents {
			ids = append(ids, id)
		}
		return ids
	case repositoryforent.EdgeIssueForEnts:
		ids := make([]ent.Value, 0, len(m.removedissue_for_ents))
		for id := range m.removedissue_for_ents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryForEntMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser_for_ents {
		edges = append(edges, repositoryforent.EdgeUserForEnts)
	}
	if m.clearedissue_for_ents {
		edges = append(edges, repositoryforent.EdgeIssueForEnts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryForEntMutation) EdgeCleared(name string) bool {
	switch name {
	case repositoryforent.EdgeUserForEnts:
		return m.cleareduser_for_ents
	case repositoryforent.EdgeIssueForEnts:
		return m.clearedissue_for_ents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryForEntMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RepositoryForEnt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryForEntMutation) ResetEdge(name string) error {
	switch name {
	case repositoryforent.EdgeUserForEnts:
		m.ResetUserForEnts()
		return nil
	case repositoryforent.EdgeIssueForEnts:
		m.ResetIssueForEnts()
		return nil
	}
	return fmt.Errorf("unknown RepositoryForEnt edge %s", name)
}

// Table01ForEntMutation represents an operation that mutates the Table01ForEnt nodes in the graph.
type Table01ForEntMutation struct {
	config
	op                Op
	typ               string
	id                *int
	common_field01    *int
	addcommon_field01 *int
	create_time       *time.Time
	update_time       *time.Time
	field01           *string
	field02           *int
	addfield02        *int
	field03           *bool
	field04           *table01forent.Field04
	field05           *string
	field06           *string
	field07           *int64
	addfield07        *int64
	field08           *float64
	addfield08        *float64
	field09           *string
	field10           *string
	field11           *string
	field12           *string
	field13           *string
	field14           *string
	field15           *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Table01ForEnt, error)
	predicates        []predicate.Table01ForEnt
}

var _ ent.Mutation = (*Table01ForEntMutation)(nil)

// table01forentOption allows management of the mutation configuration using functional options.
type table01forentOption func(*Table01ForEntMutation)

// newTable01ForEntMutation creates new mutation for the Table01ForEnt entity.
func newTable01ForEntMutation(c config, op Op, opts ...table01forentOption) *Table01ForEntMutation {
	m := &Table01ForEntMutation{
		config:        c,
		op:            op,
		typ:           TypeTable01ForEnt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTable01ForEntID sets the ID field of the mutation.
func withTable01ForEntID(id int) table01forentOption {
	return func(m *Table01ForEntMutation) {
		var (
			err   error
			once  sync.Once
			value *Table01ForEnt
		)
		m.oldValue = func(ctx context.Context) (*Table01ForEnt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Table01ForEnt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTable01ForEnt sets the old Table01ForEnt of the mutation.
func withTable01ForEnt(node *Table01ForEnt) table01forentOption {
	return func(m *Table01ForEntMutation) {
		m.oldValue = func(context.Context) (*Table01ForEnt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Table01ForEntMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Table01ForEntMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Table01ForEntMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Table01ForEntMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Table01ForEnt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommonField01 sets the "common_field01" field.
func (m *Table01ForEntMutation) SetCommonField01(i int) {
	m.common_field01 = &i
	m.addcommon_field01 = nil
}

// CommonField01 returns the value of the "common_field01" field in the mutation.
func (m *Table01ForEntMutation) CommonField01() (r int, exists bool) {
	v := m.common_field01
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonField01 returns the old "common_field01" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldCommonField01(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonField01 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonField01 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonField01: %w", err)
	}
	return oldValue.CommonField01, nil
}

// AddCommonField01 adds i to the "common_field01" field.
func (m *Table01ForEntMutation) AddCommonField01(i int) {
	if m.addcommon_field01 != nil {
		*m.addcommon_field01 += i
	} else {
		m.addcommon_field01 = &i
	}
}

// AddedCommonField01 returns the value that was added to the "common_field01" field in this mutation.
func (m *Table01ForEntMutation) AddedCommonField01() (r int, exists bool) {
	v := m.addcommon_field01
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommonField01 clears the value of the "common_field01" field.
func (m *Table01ForEntMutation) ClearCommonField01() {
	m.common_field01 = nil
	m.addcommon_field01 = nil
	m.clearedFields[table01forent.FieldCommonField01] = struct{}{}
}

// CommonField01Cleared returns if the "common_field01" field was cleared in this mutation.
func (m *Table01ForEntMutation) CommonField01Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldCommonField01]
	return ok
}

// ResetCommonField01 resets all changes to the "common_field01" field.
func (m *Table01ForEntMutation) ResetCommonField01() {
	m.common_field01 = nil
	m.addcommon_field01 = nil
	delete(m.clearedFields, table01forent.FieldCommonField01)
}

// SetCreateTime sets the "create_time" field.
func (m *Table01ForEntMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *Table01ForEntMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *Table01ForEntMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *Table01ForEntMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *Table01ForEntMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *Table01ForEntMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetField01 sets the "field01" field.
func (m *Table01ForEntMutation) SetField01(s string) {
	m.field01 = &s
}

// Field01 returns the value of the "field01" field in the mutation.
func (m *Table01ForEntMutation) Field01() (r string, exists bool) {
	v := m.field01
	if v == nil {
		return
	}
	return *v, true
}

// OldField01 returns the old "field01" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField01(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField01 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField01 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField01: %w", err)
	}
	return oldValue.Field01, nil
}

// ResetField01 resets all changes to the "field01" field.
func (m *Table01ForEntMutation) ResetField01() {
	m.field01 = nil
}

// SetField02 sets the "field02" field.
func (m *Table01ForEntMutation) SetField02(i int) {
	m.field02 = &i
	m.addfield02 = nil
}

// Field02 returns the value of the "field02" field in the mutation.
func (m *Table01ForEntMutation) Field02() (r int, exists bool) {
	v := m.field02
	if v == nil {
		return
	}
	return *v, true
}

// OldField02 returns the old "field02" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField02(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField02 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField02 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField02: %w", err)
	}
	return oldValue.Field02, nil
}

// AddField02 adds i to the "field02" field.
func (m *Table01ForEntMutation) AddField02(i int) {
	if m.addfield02 != nil {
		*m.addfield02 += i
	} else {
		m.addfield02 = &i
	}
}

// AddedField02 returns the value that was added to the "field02" field in this mutation.
func (m *Table01ForEntMutation) AddedField02() (r int, exists bool) {
	v := m.addfield02
	if v == nil {
		return
	}
	return *v, true
}

// ResetField02 resets all changes to the "field02" field.
func (m *Table01ForEntMutation) ResetField02() {
	m.field02 = nil
	m.addfield02 = nil
}

// SetField03 sets the "field03" field.
func (m *Table01ForEntMutation) SetField03(b bool) {
	m.field03 = &b
}

// Field03 returns the value of the "field03" field in the mutation.
func (m *Table01ForEntMutation) Field03() (r bool, exists bool) {
	v := m.field03
	if v == nil {
		return
	}
	return *v, true
}

// OldField03 returns the old "field03" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField03(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField03 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField03 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField03: %w", err)
	}
	return oldValue.Field03, nil
}

// ResetField03 resets all changes to the "field03" field.
func (m *Table01ForEntMutation) ResetField03() {
	m.field03 = nil
}

// SetField04 sets the "field04" field.
func (m *Table01ForEntMutation) SetField04(t table01forent.Field04) {
	m.field04 = &t
}

// Field04 returns the value of the "field04" field in the mutation.
func (m *Table01ForEntMutation) Field04() (r table01forent.Field04, exists bool) {
	v := m.field04
	if v == nil {
		return
	}
	return *v, true
}

// OldField04 returns the old "field04" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField04(ctx context.Context) (v table01forent.Field04, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField04 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField04 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField04: %w", err)
	}
	return oldValue.Field04, nil
}

// ResetField04 resets all changes to the "field04" field.
func (m *Table01ForEntMutation) ResetField04() {
	m.field04 = nil
}

// SetField05 sets the "field05" field.
func (m *Table01ForEntMutation) SetField05(s string) {
	m.field05 = &s
}

// Field05 returns the value of the "field05" field in the mutation.
func (m *Table01ForEntMutation) Field05() (r string, exists bool) {
	v := m.field05
	if v == nil {
		return
	}
	return *v, true
}

// OldField05 returns the old "field05" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField05(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField05 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField05 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField05: %w", err)
	}
	return oldValue.Field05, nil
}

// ClearField05 clears the value of the "field05" field.
func (m *Table01ForEntMutation) ClearField05() {
	m.field05 = nil
	m.clearedFields[table01forent.FieldField05] = struct{}{}
}

// Field05Cleared returns if the "field05" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field05Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField05]
	return ok
}

// ResetField05 resets all changes to the "field05" field.
func (m *Table01ForEntMutation) ResetField05() {
	m.field05 = nil
	delete(m.clearedFields, table01forent.FieldField05)
}

// SetField06 sets the "field06" field.
func (m *Table01ForEntMutation) SetField06(s string) {
	m.field06 = &s
}

// Field06 returns the value of the "field06" field in the mutation.
func (m *Table01ForEntMutation) Field06() (r string, exists bool) {
	v := m.field06
	if v == nil {
		return
	}
	return *v, true
}

// OldField06 returns the old "field06" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField06(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField06 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField06 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField06: %w", err)
	}
	return oldValue.Field06, nil
}

// ClearField06 clears the value of the "field06" field.
func (m *Table01ForEntMutation) ClearField06() {
	m.field06 = nil
	m.clearedFields[table01forent.FieldField06] = struct{}{}
}

// Field06Cleared returns if the "field06" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field06Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField06]
	return ok
}

// ResetField06 resets all changes to the "field06" field.
func (m *Table01ForEntMutation) ResetField06() {
	m.field06 = nil
	delete(m.clearedFields, table01forent.FieldField06)
}

// SetField07 sets the "field07" field.
func (m *Table01ForEntMutation) SetField07(i int64) {
	m.field07 = &i
	m.addfield07 = nil
}

// Field07 returns the value of the "field07" field in the mutation.
func (m *Table01ForEntMutation) Field07() (r int64, exists bool) {
	v := m.field07
	if v == nil {
		return
	}
	return *v, true
}

// OldField07 returns the old "field07" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField07(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField07 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField07 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField07: %w", err)
	}
	return oldValue.Field07, nil
}

// AddField07 adds i to the "field07" field.
func (m *Table01ForEntMutation) AddField07(i int64) {
	if m.addfield07 != nil {
		*m.addfield07 += i
	} else {
		m.addfield07 = &i
	}
}

// AddedField07 returns the value that was added to the "field07" field in this mutation.
func (m *Table01ForEntMutation) AddedField07() (r int64, exists bool) {
	v := m.addfield07
	if v == nil {
		return
	}
	return *v, true
}

// ResetField07 resets all changes to the "field07" field.
func (m *Table01ForEntMutation) ResetField07() {
	m.field07 = nil
	m.addfield07 = nil
}

// SetField08 sets the "field08" field.
func (m *Table01ForEntMutation) SetField08(f float64) {
	m.field08 = &f
	m.addfield08 = nil
}

// Field08 returns the value of the "field08" field in the mutation.
func (m *Table01ForEntMutation) Field08() (r float64, exists bool) {
	v := m.field08
	if v == nil {
		return
	}
	return *v, true
}

// OldField08 returns the old "field08" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField08(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField08 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField08 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField08: %w", err)
	}
	return oldValue.Field08, nil
}

// AddField08 adds f to the "field08" field.
func (m *Table01ForEntMutation) AddField08(f float64) {
	if m.addfield08 != nil {
		*m.addfield08 += f
	} else {
		m.addfield08 = &f
	}
}

// AddedField08 returns the value that was added to the "field08" field in this mutation.
func (m *Table01ForEntMutation) AddedField08() (r float64, exists bool) {
	v := m.addfield08
	if v == nil {
		return
	}
	return *v, true
}

// ResetField08 resets all changes to the "field08" field.
func (m *Table01ForEntMutation) ResetField08() {
	m.field08 = nil
	m.addfield08 = nil
}

// SetField09 sets the "field09" field.
func (m *Table01ForEntMutation) SetField09(s string) {
	m.field09 = &s
}

// Field09 returns the value of the "field09" field in the mutation.
func (m *Table01ForEntMutation) Field09() (r string, exists bool) {
	v := m.field09
	if v == nil {
		return
	}
	return *v, true
}

// OldField09 returns the old "field09" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField09(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField09 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField09 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField09: %w", err)
	}
	return oldValue.Field09, nil
}

// ResetField09 resets all changes to the "field09" field.
func (m *Table01ForEntMutation) ResetField09() {
	m.field09 = nil
}

// SetField10 sets the "field10" field.
func (m *Table01ForEntMutation) SetField10(s string) {
	m.field10 = &s
}

// Field10 returns the value of the "field10" field in the mutation.
func (m *Table01ForEntMutation) Field10() (r string, exists bool) {
	v := m.field10
	if v == nil {
		return
	}
	return *v, true
}

// OldField10 returns the old "field10" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField10(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField10 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField10 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField10: %w", err)
	}
	return oldValue.Field10, nil
}

// ClearField10 clears the value of the "field10" field.
func (m *Table01ForEntMutation) ClearField10() {
	m.field10 = nil
	m.clearedFields[table01forent.FieldField10] = struct{}{}
}

// Field10Cleared returns if the "field10" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field10Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField10]
	return ok
}

// ResetField10 resets all changes to the "field10" field.
func (m *Table01ForEntMutation) ResetField10() {
	m.field10 = nil
	delete(m.clearedFields, table01forent.FieldField10)
}

// SetField11 sets the "field11" field.
func (m *Table01ForEntMutation) SetField11(s string) {
	m.field11 = &s
}

// Field11 returns the value of the "field11" field in the mutation.
func (m *Table01ForEntMutation) Field11() (r string, exists bool) {
	v := m.field11
	if v == nil {
		return
	}
	return *v, true
}

// OldField11 returns the old "field11" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField11(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField11 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField11 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField11: %w", err)
	}
	return oldValue.Field11, nil
}

// ClearField11 clears the value of the "field11" field.
func (m *Table01ForEntMutation) ClearField11() {
	m.field11 = nil
	m.clearedFields[table01forent.FieldField11] = struct{}{}
}

// Field11Cleared returns if the "field11" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field11Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField11]
	return ok
}

// ResetField11 resets all changes to the "field11" field.
func (m *Table01ForEntMutation) ResetField11() {
	m.field11 = nil
	delete(m.clearedFields, table01forent.FieldField11)
}

// SetField12 sets the "field12" field.
func (m *Table01ForEntMutation) SetField12(s string) {
	m.field12 = &s
}

// Field12 returns the value of the "field12" field in the mutation.
func (m *Table01ForEntMutation) Field12() (r string, exists bool) {
	v := m.field12
	if v == nil {
		return
	}
	return *v, true
}

// OldField12 returns the old "field12" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField12(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField12 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField12 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField12: %w", err)
	}
	return oldValue.Field12, nil
}

// ClearField12 clears the value of the "field12" field.
func (m *Table01ForEntMutation) ClearField12() {
	m.field12 = nil
	m.clearedFields[table01forent.FieldField12] = struct{}{}
}

// Field12Cleared returns if the "field12" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field12Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField12]
	return ok
}

// ResetField12 resets all changes to the "field12" field.
func (m *Table01ForEntMutation) ResetField12() {
	m.field12 = nil
	delete(m.clearedFields, table01forent.FieldField12)
}

// SetField13 sets the "field13" field.
func (m *Table01ForEntMutation) SetField13(s string) {
	m.field13 = &s
}

// Field13 returns the value of the "field13" field in the mutation.
func (m *Table01ForEntMutation) Field13() (r string, exists bool) {
	v := m.field13
	if v == nil {
		return
	}
	return *v, true
}

// OldField13 returns the old "field13" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField13(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField13 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField13 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField13: %w", err)
	}
	return oldValue.Field13, nil
}

// ClearField13 clears the value of the "field13" field.
func (m *Table01ForEntMutation) ClearField13() {
	m.field13 = nil
	m.clearedFields[table01forent.FieldField13] = struct{}{}
}

// Field13Cleared returns if the "field13" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field13Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField13]
	return ok
}

// ResetField13 resets all changes to the "field13" field.
func (m *Table01ForEntMutation) ResetField13() {
	m.field13 = nil
	delete(m.clearedFields, table01forent.FieldField13)
}

// SetField14 sets the "field14" field.
func (m *Table01ForEntMutation) SetField14(s string) {
	m.field14 = &s
}

// Field14 returns the value of the "field14" field in the mutation.
func (m *Table01ForEntMutation) Field14() (r string, exists bool) {
	v := m.field14
	if v == nil {
		return
	}
	return *v, true
}

// OldField14 returns the old "field14" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField14(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField14 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField14 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField14: %w", err)
	}
	return oldValue.Field14, nil
}

// ClearField14 clears the value of the "field14" field.
func (m *Table01ForEntMutation) ClearField14() {
	m.field14 = nil
	m.clearedFields[table01forent.FieldField14] = struct{}{}
}

// Field14Cleared returns if the "field14" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field14Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField14]
	return ok
}

// ResetField14 resets all changes to the "field14" field.
func (m *Table01ForEntMutation) ResetField14() {
	m.field14 = nil
	delete(m.clearedFields, table01forent.FieldField14)
}

// SetField15 sets the "field15" field.
func (m *Table01ForEntMutation) SetField15(s string) {
	m.field15 = &s
}

// Field15 returns the value of the "field15" field in the mutation.
func (m *Table01ForEntMutation) Field15() (r string, exists bool) {
	v := m.field15
	if v == nil {
		return
	}
	return *v, true
}

// OldField15 returns the old "field15" field's value of the Table01ForEnt entity.
// If the Table01ForEnt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Table01ForEntMutation) OldField15(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldField15 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldField15 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldField15: %w", err)
	}
	return oldValue.Field15, nil
}

// ClearField15 clears the value of the "field15" field.
func (m *Table01ForEntMutation) ClearField15() {
	m.field15 = nil
	m.clearedFields[table01forent.FieldField15] = struct{}{}
}

// Field15Cleared returns if the "field15" field was cleared in this mutation.
func (m *Table01ForEntMutation) Field15Cleared() bool {
	_, ok := m.clearedFields[table01forent.FieldField15]
	return ok
}

// ResetField15 resets all changes to the "field15" field.
func (m *Table01ForEntMutation) ResetField15() {
	m.field15 = nil
	delete(m.clearedFields, table01forent.FieldField15)
}

// Where appends a list predicates to the Table01ForEntMutation builder.
func (m *Table01ForEntMutation) Where(ps ...predicate.Table01ForEnt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Table01ForEntMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Table01ForEntMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Table01ForEnt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Table01ForEntMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Table01ForEntMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Table01ForEnt).
func (m *Table01ForEntMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Table01ForEntMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.common_field01 != nil {
		fields = append(fields, table01forent.FieldCommonField01)
	}
	if m.create_time != nil {
		fields = append(fields, table01forent.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, table01forent.FieldUpdateTime)
	}
	if m.field01 != nil {
		fields = append(fields, table01forent.FieldField01)
	}
	if m.field02 != nil {
		fields = append(fields, table01forent.FieldField02)
	}
	if m.field03 != nil {
		fields = append(fields, table01forent.FieldField03)
	}
	if m.field04 != nil {
		fields = append(fields, table01forent.FieldField04)
	}
	if m.field05 != nil {
		fields = append(fields, table01forent.FieldField05)
	}
	if m.field06 != nil {
		fields = append(fields, table01forent.FieldField06)
	}
	if m.field07 != nil {
		fields = append(fields, table01forent.FieldField07)
	}
	if m.field08 != nil {
		fields = append(fields, table01forent.FieldField08)
	}
	if m.field09 != nil {
		fields = append(fields, table01forent.FieldField09)
	}
	if m.field10 != nil {
		fields = append(fields, table01forent.FieldField10)
	}
	if m.field11 != nil {
		fields = append(fields, table01forent.FieldField11)
	}
	if m.field12 != nil {
		fields = append(fields, table01forent.FieldField12)
	}
	if m.field13 != nil {
		fields = append(fields, table01forent.FieldField13)
	}
	if m.field14 != nil {
		fields = append(fields, table01forent.FieldField14)
	}
	if m.field15 != nil {
		fields = append(fields, table01forent.FieldField15)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Table01ForEntMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case table01forent.FieldCommonField01:
		return m.CommonField01()
	case table01forent.FieldCreateTime:
		return m.CreateTime()
	case table01forent.FieldUpdateTime:
		return m.UpdateTime()
	case table01forent.FieldField01:
		return m.Field01()
	case table01forent.FieldField02:
		return m.Field02()
	case table01forent.FieldField03:
		return m.Field03()
	case table01forent.FieldField04:
		return m.Field04()
	case table01forent.FieldField05:
		return m.Field05()
	case table01forent.FieldField06:
		return m.Field06()
	case table01forent.FieldField07:
		return m.Field07()
	case table01forent.FieldField08:
		return m.Field08()
	case table01forent.FieldField09:
		return m.Field09()
	case table01forent.FieldField10:
		return m.Field10()
	case table01forent.FieldField11:
		return m.Field11()
	case table01forent.FieldField12:
		return m.Field12()
	case table01forent.FieldField13:
		return m.Field13()
	case table01forent.FieldField14:
		return m.Field14()
	case table01forent.FieldField15:
		return m.Field15()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Table01ForEntMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case table01forent.FieldCommonField01:
		return m.OldCommonField01(ctx)
	case table01forent.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case table01forent.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case table01forent.FieldField01:
		return m.OldField01(ctx)
	case table01forent.FieldField02:
		return m.OldField02(ctx)
	case table01forent.FieldField03:
		return m.OldField03(ctx)
	case table01forent.FieldField04:
		return m.OldField04(ctx)
	case table01forent.FieldField05:
		return m.OldField05(ctx)
	case table01forent.FieldField06:
		return m.OldField06(ctx)
	case table01forent.FieldField07:
		return m.OldField07(ctx)
	case table01forent.FieldField08:
		return m.OldField08(ctx)
	case table01forent.FieldField09:
		return m.OldField09(ctx)
	case table01forent.FieldField10:
		return m.OldField10(ctx)
	case table01forent.FieldField11:
		return m.OldField11(ctx)
	case table01forent.FieldField12:
		return m.OldField12(ctx)
	case table01forent.FieldField13:
		return m.OldField13(ctx)
	case table01forent.FieldField14:
		return m.OldField14(ctx)
	case table01forent.FieldField15:
		return m.OldField15(ctx)
	}
	return nil, fmt.Errorf("unknown Table01ForEnt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Table01ForEntMutation) SetField(name string, value ent.Value) error {
	switch name {
	case table01forent.FieldCommonField01:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonField01(v)
		return nil
	case table01forent.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case table01forent.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case table01forent.FieldField01:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField01(v)
		return nil
	case table01forent.FieldField02:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField02(v)
		return nil
	case table01forent.FieldField03:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField03(v)
		return nil
	case table01forent.FieldField04:
		v, ok := value.(table01forent.Field04)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField04(v)
		return nil
	case table01forent.FieldField05:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField05(v)
		return nil
	case table01forent.FieldField06:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField06(v)
		return nil
	case table01forent.FieldField07:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField07(v)
		return nil
	case table01forent.FieldField08:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField08(v)
		return nil
	case table01forent.FieldField09:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField09(v)
		return nil
	case table01forent.FieldField10:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField10(v)
		return nil
	case table01forent.FieldField11:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField11(v)
		return nil
	case table01forent.FieldField12:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField12(v)
		return nil
	case table01forent.FieldField13:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField13(v)
		return nil
	case table01forent.FieldField14:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField14(v)
		return nil
	case table01forent.FieldField15:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetField15(v)
		return nil
	}
	return fmt.Errorf("unknown Table01ForEnt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Table01ForEntMutation) AddedFields() []string {
	var fields []string
	if m.addcommon_field01 != nil {
		fields = append(fields, table01forent.FieldCommonField01)
	}
	if m.addfield02 != nil {
		fields = append(fields, table01forent.FieldField02)
	}
	if m.addfield07 != nil {
		fields = append(fields, table01forent.FieldField07)
	}
	if m.addfield08 != nil {
		fields = append(fields, table01forent.FieldField08)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Table01ForEntMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case table01forent.FieldCommonField01:
		return m.AddedCommonField01()
	case table01forent.FieldField02:
		return m.AddedField02()
	case table01forent.FieldField07:
		return m.AddedField07()
	case table01forent.FieldField08:
		return m.AddedField08()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Table01ForEntMutation) AddField(name string, value ent.Value) error {
	switch name {
	case table01forent.FieldCommonField01:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommonField01(v)
		return nil
	case table01forent.FieldField02:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddField02(v)
		return nil
	case table01forent.FieldField07:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddField07(v)
		return nil
	case table01forent.FieldField08:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddField08(v)
		return nil
	}
	return fmt.Errorf("unknown Table01ForEnt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Table01ForEntMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(table01forent.FieldCommonField01) {
		fields = append(fields, table01forent.FieldCommonField01)
	}
	if m.FieldCleared(table01forent.FieldField05) {
		fields = append(fields, table01forent.FieldField05)
	}
	if m.FieldCleared(table01forent.FieldField06) {
		fields = append(fields, table01forent.FieldField06)
	}
	if m.FieldCleared(table01forent.FieldField10) {
		fields = append(fields, table01forent.FieldField10)
	}
	if m.FieldCleared(table01forent.FieldField11) {
		fields = append(fields, table01forent.FieldField11)
	}
	if m.FieldCleared(table01forent.FieldField12) {
		fields = append(fields, table01forent.FieldField12)
	}
	if m.FieldCleared(table01forent.FieldField13) {
		fields = append(fields, table01forent.FieldField13)
	}
	if m.FieldCleared(table01forent.FieldField14) {
		fields = append(fields, table01forent.FieldField14)
	}
	if m.FieldCleared(table01forent.FieldField15) {
		fields = append(fields, table01forent.FieldField15)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Table01ForEntMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Table01ForEntMutation) ClearField(name string) error {
	switch name {
	case table01forent.FieldCommonField01:
		m.ClearCommonField01()
		return nil
	case table01forent.FieldField05:
		m.ClearField05()
		return nil
	case table01forent.FieldField06:
		m.ClearField06()
		return nil
	case table01forent.FieldField10:
		m.ClearField10()
		return nil
	case table01forent.FieldField11:
		m.ClearField11()
		return nil
	case table01forent.FieldField12:
		m.ClearField12()
		return nil
	case table01forent.FieldField13:
		m.ClearField13()
		return nil
	case table01forent.FieldField14:
		m.ClearField14()
		return nil
	case table01forent.FieldField15:
		m.ClearField15()
		return nil
	}
	return fmt.Errorf("unknown Table01ForEnt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Table01ForEntMutation) ResetField(name string) error {
	switch name {
	case table01forent.FieldCommonField01:
		m.ResetCommonField01()
		return nil
	case table01forent.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case table01forent.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case table01forent.FieldField01:
		m.ResetField01()
		return nil
	case table01forent.FieldField02:
		m.ResetField02()
		return nil
	case table01forent.FieldField03:
		m.ResetField03()
		return nil
	case table01forent.FieldField04:
		m.ResetField04()
		return nil
	case table01forent.FieldField05:
		m.ResetField05()
		return nil
	case table01forent.FieldField06:
		m.ResetField06()
		return nil
	case table01forent.FieldField07:
		m.ResetField07()
		return nil
	case table01forent.FieldField08:
		m.ResetField08()
		return nil
	case table01forent.FieldField09:
		m.ResetField09()
		return nil
	case table01forent.FieldField10:
		m.ResetField10()
		return nil
	case table01forent.FieldField11:
		m.ResetField11()
		return nil
	case table01forent.FieldField12:
		m.ResetField12()
		return nil
	case table01forent.FieldField13:
		m.ResetField13()
		return nil
	case table01forent.FieldField14:
		m.ResetField14()
		return nil
	case table01forent.FieldField15:
		m.ResetField15()
		return nil
	}
	return fmt.Errorf("unknown Table01ForEnt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Table01ForEntMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Table01ForEntMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Table01ForEntMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Table01ForEntMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Table01ForEntMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Table01ForEntMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Table01ForEntMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Table01ForEnt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Table01ForEntMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Table01ForEnt edge %s", name)
}

// UserForEntMutation represents an operation that mutates the UserForEnt nodes in the graph.
type UserForEntMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	clearedFields              map[string]struct{}
	repository_for_ents        map[int]struct{}
	removedrepository_for_ents map[int]struct{}
	clearedrepository_for_ents bool
	done                       bool
	oldValue                   func(context.Context) (*UserForEnt, error)
	predicates                 []predicate.UserForEnt
}

var _ ent.Mutation = (*UserForEntMutation)(nil)

// userforentOption allows management of the mutation configuration using functional options.
type userforentOption func(*UserForEntMutation)

// newUserForEntMutation creates new mutation for the UserForEnt entity.
func newUserForEntMutation(c config, op Op, opts ...userforentOption) *UserForEntMutation {
	m := &UserForEntMutation{
		config:        c,
		op:            op,
		typ:           TypeUserForEnt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserForEntID sets the ID field of the mutation.
func withUserForEntID(id int) userforentOption {
	return func(m *UserForEntMutation) {
		var (
			err   error
			once  sync.Once
			value *UserForEnt
		)
		m.oldValue = func(ctx context.Context) (*UserForEnt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserForEnt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserForEnt sets the old UserForEnt of the mutation.
func withUserForEnt(node *UserForEnt) userforentOption {
	return func(m *UserForEntMutation) {
		m.oldValue = func(context.Context) (*UserForEnt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserForEntMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserForEntMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserForEntMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserForEntMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserForEnt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddRepositoryForEntIDs adds the "repository_for_ents" edge to the RepositoryForEnt entity by ids.
func (m *UserForEntMutation) AddRepositoryForEntIDs(ids ...int) {
	if m.repository_for_ents == nil {
		m.repository_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		m.repository_for_ents[ids[i]] = struct{}{}
	}
}

// ClearRepositoryForEnts clears the "repository_for_ents" edge to the RepositoryForEnt entity.
func (m *UserForEntMutation) ClearRepositoryForEnts() {
	m.clearedrepository_for_ents = true
}

// RepositoryForEntsCleared reports if the "repository_for_ents" edge to the RepositoryForEnt entity was cleared.
func (m *UserForEntMutation) RepositoryForEntsCleared() bool {
	return m.clearedrepository_for_ents
}

// RemoveRepositoryForEntIDs removes the "repository_for_ents" edge to the RepositoryForEnt entity by IDs.
func (m *UserForEntMutation) RemoveRepositoryForEntIDs(ids ...int) {
	if m.removedrepository_for_ents == nil {
		m.removedrepository_for_ents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.repository_for_ents, ids[i])
		m.removedrepository_for_ents[ids[i]] = struct{}{}
	}
}

// RemovedRepositoryForEnts returns the removed IDs of the "repository_for_ents" edge to the RepositoryForEnt entity.
func (m *UserForEntMutation) RemovedRepositoryForEntsIDs() (ids []int) {
	for id := range m.removedrepository_for_ents {
		ids = append(ids, id)
	}
	return
}

// RepositoryForEntsIDs returns the "repository_for_ents" edge IDs in the mutation.
func (m *UserForEntMutation) RepositoryForEntsIDs() (ids []int) {
	for id := range m.repository_for_ents {
		ids = append(ids, id)
	}
	return
}

// ResetRepositoryForEnts resets all changes to the "repository_for_ents" edge.
func (m *UserForEntMutation) ResetRepositoryForEnts() {
	m.repository_for_ents = nil
	m.clearedrepository_for_ents = false
	m.removedrepository_for_ents = nil
}

// Where appends a list predicates to the UserForEntMutation builder.
func (m *UserForEntMutation) Where(ps ...predicate.UserForEnt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserForEntMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserForEntMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserForEnt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserForEntMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserForEntMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserForEnt).
func (m *UserForEntMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserForEntMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserForEntMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserForEntMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UserForEnt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForEntMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserForEnt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserForEntMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserForEntMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserForEntMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UserForEnt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserForEntMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserForEntMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserForEntMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserForEnt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserForEntMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UserForEnt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserForEntMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.repository_for_ents != nil {
		edges = append(edges, userforent.EdgeRepositoryForEnts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserForEntMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userforent.EdgeRepositoryForEnts:
		ids := make([]ent.Value, 0, len(m.repository_for_ents))
		for id := range m.repository_for_ents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserForEntMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrepository_for_ents != nil {
		edges = append(edges, userforent.EdgeRepositoryForEnts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserForEntMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userforent.EdgeRepositoryForEnts:
		ids := make([]ent.Value, 0, len(m.removedrepository_for_ents))
		for id := range m.removedrepository_for_ents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserForEntMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrepository_for_ents {
		edges = append(edges, userforent.EdgeRepositoryForEnts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserForEntMutation) EdgeCleared(name string) bool {
	switch name {
	case userforent.EdgeRepositoryForEnts:
		return m.clearedrepository_for_ents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserForEntMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserForEnt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserForEntMutation) ResetEdge(name string) error {
	switch name {
	case userforent.EdgeRepositoryForEnts:
		m.ResetRepositoryForEnts()
		return nil
	}
	return fmt.Errorf("unknown UserForEnt edge %s", name)
}
